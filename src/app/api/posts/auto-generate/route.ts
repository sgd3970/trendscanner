import { NextResponse } from 'next/server';
import connectDB from '@/lib/mongodb';
import KeywordCache from '@/models/KeywordCache';
import Post from '@/models/Post';
import OpenAI from 'openai';
import { createApi } from 'unsplash-js';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY!,
});

const unsplash = createApi({
  accessKey: process.env.UNSPLASH_ACCESS_KEY!,
});

export const dynamic = 'force-dynamic';
export const revalidate = 0;
export const maxDuration = 60;

function generateSlug(title: string): string {
  return title
    .toLowerCase()
    .replace(/[^ã„±-ía-z0-9\s-]/g, '')
    .replace(/\s+/g, '-')
    .replace(/--+/g, '-')
    .replace(/^-+|-+$/g, '');
}

export async function POST(request: Request) {
  try {
    await connectDB();

    const { keywordCount } = await request.json();
    if (!keywordCount || keywordCount < 1 || keywordCount > 5) {
      return NextResponse.json(
        { error: 'í‚¤ì›Œë“œ ê°œìˆ˜ëŠ” 1~5ê°œ ì‚¬ì´ì—¬ì•¼ í•©ë‹ˆë‹¤.' },
        { status: 400 }
      );
    }

    const unusedKeywords = await KeywordCache.find({ used: false });
    if (unusedKeywords.length < keywordCount) {
      return NextResponse.json(
        { error: 'ì‚¬ìš© ê°€ëŠ¥í•œ í‚¤ì›Œë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.' },
        { status: 400 }
      );
    }

    const selectedKeywords = unusedKeywords.sort(() => 0.5 - Math.random()).slice(0, keywordCount);
    const createdPosts = [];

    for (const { keyword, _id } of selectedKeywords) {
      try {
        const prompt = `
ë‹¹ì‹ ì€ ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ë¶„ì„ ë¸”ë¡œê·¸ì˜ ì¹¼ëŸ¼ë‹ˆìŠ¤íŠ¸ì…ë‹ˆë‹¤.

ğŸ§  ëª©í‘œ: ì§€ê¸ˆ ë§‰ ì£¼ëª©ë°›ê¸° ì‹œì‘í•œ í‚¤ì›Œë“œë¥¼ ë…ìë“¤ì—ê²Œ **ì‰½ê³  í¥ë¯¸ë¡­ê²Œ** ì„¤ëª…í•˜ê³ , ì™œ ì¤‘ìš”í•œì§€ **ì¸ì‚¬ì´íŠ¸**ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

âœï¸ ê¸€ì“°ê¸° ê·œì¹™:
- ì „ì²´ ê¸€ì ìˆ˜: **ìµœì†Œ 1500ì ì´ìƒ**
- ê¸€ ìŠ¤íƒ€ì¼: **ë‰´ìŠ¤ì™€ ë¸”ë¡œê·¸ì˜ ì¤‘ê°„**, ìì—°ìŠ¤ëŸ¬ìš´ ë§íˆ¬
- ì†Œì œëª©: ë¬¸ì¥í˜•ìœ¼ë¡œ 3ê°œ ì´ìƒ (ì§ˆë¬¸í˜•ì´ë©´ ë”ìš± ì¢‹ìŒ)
- ê° ì†Œì œëª©ì—ëŠ” ë‹¤ìŒ íë¦„ì„ í¬í•¨í•˜ì„¸ìš”:
  â‘  íŠ¸ë Œë“œ ì„¤ëª… â†’ â‘¡ ì‹¤ì œ ì‚¬ë¡€ ë˜ëŠ” ë°˜ì‘ â†’ â‘¢ ì¸ì‚¬ì´íŠ¸ë‚˜ í•´ì„
- ë§ˆì§€ë§‰ì—” ë…ìì—ê²Œ ì§ˆë¬¸ ë˜ëŠ” ì „ë§ì„ ì œì‹œí•˜ëŠ” ë§ˆë¬´ë¦¬ ë¬¸ë‹¨ í¬í•¨

ğŸ“¦ ì¶œë ¥ í˜•ì‹ (JSON only)
{
  "title": "ë…ìê°€ í´ë¦­í•˜ê³  ì‹¶ì„ ë§Œí•œ í¥ë¯¸ë¡œìš´ ì œëª©",
  "content": "## (ì†Œì œëª©1)\\n\\në‚´ìš©...\\n\\n## (ì†Œì œëª©2)\\n\\në‚´ìš©...\\n\\n## (ì†Œì œëª©3)\\n\\në‚´ìš©...\\n\\n## ë§ˆë¬´ë¦¬\\n\\në‚´ìš©...",
  "hashtags": ["í‚¤ì›Œë“œ1", "í‚¤ì›Œë“œ2", "í‚¤ì›Œë“œ3", "í‚¤ì›Œë“œ4", "í‚¤ì›Œë“œ5"],
  "imageQuery": "í•´ë‹¹ í‚¤ì›Œë“œì™€ ê´€ë ¨ëœ ì˜ì–´ ì´ë¯¸ì§€ ê²€ìƒ‰ í‚¤ì›Œë“œ"
}

âœï¸ í‚¤ì›Œë“œ: ${keyword}
ì˜ˆ: ì›í”¼ìŠ¤ 1126í™” / í•˜ì´ë¸Œ ì£¼ê°€ / ê°¤ëŸ­ì‹œ S25 ë£¨ë¨¸ / íŒŒì´ì½”ì¸ ìƒì¥ / AI ê·¸ë¦¼ ì €ì‘ê¶Œ ë“±
`;

        

        

        const gptResponse = await openai.chat.completions.create({
          model: 'gpt-3.5-turbo',
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.7,
          max_tokens: 3000,
        });

        if (!gptResponse?.choices?.[0]?.message?.content) {
          throw new Error('GPT ì‘ë‹µì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
        }

        let parsedResponse;
        try {
          const raw = gptResponse.choices[0].message.content;
          const jsonMatch = raw.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            throw new Error("GPT ì‘ë‹µì´ ìœ íš¨í•œ JSON í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤.");
          }

          parsedResponse = JSON.parse(jsonMatch[0]);

          if (!parsedResponse.title || !parsedResponse.content) {
            throw new Error('í•„ìˆ˜ í•„ë“œê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤.');
          }

          parsedResponse.content = parsedResponse.content
            .replace(/!\[.*?\]\(.*?\)/g, '')
            .replace(/https?:\/\/[\S]+\.(jpg|jpeg|png|gif|webp)/gi, '')
            .trim();

          if (!Array.isArray(parsedResponse.hashtags) || parsedResponse.hashtags.length === 0) {
            parsedResponse.hashtags = [keyword];
          }

        } catch (error) {
          throw new Error(`GPT ì‘ë‹µ ì²˜ë¦¬ ì‹¤íŒ¨: ${error instanceof Error ? error.message : 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}`);
        }

        let imageUrl = '';
        try {
          const query = parsedResponse.imageQuery || parsedResponse.title || keyword;
          const imageResponse = await unsplash.photos.getRandom({ query, count: 1 });

          if (Array.isArray(imageResponse.response)) {
            imageUrl = imageResponse.response[0]?.urls?.regular || '';
          } else if (imageResponse.response?.urls?.regular) {
            imageUrl = imageResponse.response.urls.regular;
          }
        } catch (_) {
          // ì´ë¯¸ì§€ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
        }

        const post = await Post.create({
          title: parsedResponse.title || keyword,
          slug: generateSlug(parsedResponse.title || keyword),
          content: parsedResponse.content,
          imageUrl,
          tags: parsedResponse.hashtags || [keyword],
          metadata: {
            autoGenerated: true,
            keywords: [keyword],
          },
        });

        await KeywordCache.findByIdAndUpdate(_id, { used: true });

        createdPosts.push({
          _id: post._id,
          title: post.title,
          content: post.content,
          imageUrl: post.imageUrl,
          tags: post.tags,
          createdAt: post.createdAt,
        });
      } catch (_) {
        continue;
      }
    }

    if (createdPosts.length === 0) {
      return NextResponse.json(
        { error: 'í¬ìŠ¤íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.' },
        { status: 500 }
      );
    }

    return NextResponse.json({
      message: 'í¬ìŠ¤íŠ¸ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.',
      count: createdPosts.length,
      posts: createdPosts,
    });
  } catch (error) {
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'í¬ìŠ¤íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.' },
      { status: 500 }
    );
  }
}
